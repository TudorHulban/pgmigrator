package pgmigrator

import (
	"database/sql"
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/TudorHulban/pgmigrator/migration"
	"github.com/stretchr/testify/require"
)

const _migrationsTableName = "aaa_migrations"

type PGMigrator struct {
	migrationsTableName string
	migration.Migrations

	T *testing.T
}

type ParamsNewPGMigrator struct {
	MigrationsTableName sql.NullString
	Directories         []fs.FS
	FilePaths           []string

	T *testing.T
}

func NewPGMigrator(params *ParamsNewPGMigrator) *PGMigrator {
	var migrations migration.Migrations

	for _, directory := range params.Directories {
		buf, errLoad := migration.Load(
			directory,
		)
		require.NoError(params.T, errLoad)

		migrations = append(migrations, buf...)
	}

	migrations.SortByID()

	for _, filePath := range params.FilePaths {
		content, errRead := os.ReadFile(filePath)
		require.NoError(
			params.T,
			errRead,
			fmt.Errorf("failed to read file: %w", errRead),
		)

		migrations = append(migrations,
			migration.Migration{
				ID:  filepath.Base(filePath),
				SQL: string(content),
			},
		)
	}

	migrationsTableName := _migrationsTableName

	if params.MigrationsTableName.Valid {
		migrationsTableName = params.MigrationsTableName.String
	}

	return &PGMigrator{
		migrationsTableName: migrationsTableName,
		Migrations:          migrations,
		T:                   params.T,
	}
}

func (m *PGMigrator) applyMigration(db *sql.DB, item migration.Migration) {
	startedAt := time.Now().UTC()

	tx, errTx := db.Begin()
	require.NoError(m.T, errTx)

	if _, errExecSQL := tx.Exec(item.SQL); errExecSQL != nil {
		require.NoError(
			m.T,
			tx.Rollback(),
			fmt.Sprintf(
				"execution failed for %s",
				item.ID,
			),
		)
	}

	if _, errExecAudit := tx.Exec(
		`insert into `+m.migrationsTableName+`(checksum,script,miliseconds_execution_time,applied_at,success) values($1,$2,$3,$4,$5);`,

		item.MD5(),
		item.ID,
		time.Since(startedAt).Milliseconds(),
		time.Now().UTC(),
		true,
	); errExecAudit != nil {
		defer require.NoError(
			m.T,
			tx.Rollback(),
			fmt.Sprintf(
				"execution failed audit insert for %s",
				item.ID,
			),
		)

		_, errAuditFailed := db.Exec(
			`insert into `+m.migrationsTableName+`(checksum,script,miliseconds_execution_time,applied_at) values($1,$2,$3,$4);`,

			item.MD5(),
			item.ID,
			time.Since(startedAt).Milliseconds(),
			time.Now().UTC(),
		)
		require.NoError(m.T, errAuditFailed)
	}

	require.NoError(
		m.T,
		tx.Commit(),
	)
}

func (m *PGMigrator) Migrate(db *sql.DB) {
	_, errExec := db.Exec(
		`create table if not exists ` + m.migrationsTableName +
			` (id smallint generated by default as identity primary key,script text not null,checksum text not null,miliseconds_execution_time bigint not null,applied_at timestamptz not null,success bool not null default false);`,
	)
	require.NoError(
		m.T,
		errExec,

		fmt.Sprintf(
			"create migratons table: %s",
			m.migrationsTableName,
		),
	)

	for _, item := range m.Migrations {
		m.applyMigration(
			db,
			item,
		)
	}
}
