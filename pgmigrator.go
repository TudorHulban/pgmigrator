package pgmigrator

import (
	"database/sql"
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"

	"github.com/TudorHulban/pgmigrator/migration"
	"github.com/stretchr/testify/require"
)

const _migrationsTableName = "aaa_migrations"

type PGMigrator struct {
	migrationsTableName string
	migration.Migrations

	T *testing.T
}

type ParamsNewPGMigrator struct {
	MigrationsTableName sql.NullString
	Directories         []fs.FS
	FilePaths           []string
	GetIDFromFilename   migration.GetIDFromFilename

	T *testing.T
}

func NewPGMigrator(params *ParamsNewPGMigrator) *PGMigrator {
	var migrations migration.Migrations

	getID := migration.IDFromFilename

	if params.GetIDFromFilename != nil {
		getID = params.GetIDFromFilename
	}

	for _, directory := range params.Directories {
		buf, errLoad := migration.Load(
			directory,
			getID,
		)
		require.NoError(params.T, errLoad)

		migrations = append(migrations, buf...)
	}

	migrations.SortByID()

	for _, filePath := range params.FilePaths {
		content, errRead := os.ReadFile(filePath)
		require.NoError(
			params.T,
			errRead,
			fmt.Errorf("failed to read file: %w", errRead),
		)

		filename := filepath.Base(filePath)

		migrations = append(migrations,
			migration.Migration{
				ID:  strings.TrimSuffix(filename, filepath.Ext(filename)),
				SQL: string(content),
			},
		)
	}

	migrationsTableName := _migrationsTableName

	if params.MigrationsTableName.Valid {
		migrationsTableName = params.MigrationsTableName.String
	}

	return &PGMigrator{
		migrationsTableName: migrationsTableName,
		Migrations:          migrations,
		T:                   params.T,
	}
}

func (m *PGMigrator) applyMigration(db *sql.DB, item migration.Migration) {
	startedAt := time.Now().UTC()

	tx, errTx := db.Begin()
	require.NoError(m.T, errTx)

	if _, errExecSQL := tx.Exec(item.SQL); errExecSQL != nil {
		require.NoError(
			m.T,
			tx.Rollback(),
			fmt.Sprintf(
				"execution failed for %s",
				item.ID,
			),
		)
	}

	if _, errExecAudit := tx.Exec(
		`insert into `+m.migrationsTableName+`(checksum,script,miliseconds_execution_time,applied_at) values($1,$2,$3,$4);`,

		item.MD5(),
		item.ID,
		time.Since(startedAt).Milliseconds(),
		time.Now().UTC(),
	); errExecAudit != nil {
		require.NoError(
			m.T,
			tx.Rollback(),
			fmt.Sprintf(
				"execution failed audit insert for %s",
				item.ID,
			),
		)
	}
}

func (m *PGMigrator) Migrate(db *sql.DB) {
	_, errExec := db.Exec(
		`create table if not exists `+m.migrationsTableName+` (id smallint generated by default as identity primary key,script text not null,checksum text not null,miliseconds_execution_time bigint not null,applied_at timestamptz not null);`,
		m.migrationsTableName,
	)
	require.NoError(m.T, errExec)

	for _, item := range m.Migrations {
		m.applyMigration(
			db,
			item,
		)
	}
}
